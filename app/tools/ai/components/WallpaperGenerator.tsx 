'use client';

import React, { useState, useEffect } from 'react';
import { Download, X, Sparkles, Clock } from 'lucide-react';

interface SavedImage {
  id: string;
  url: string;
  prompt: string;
  width: number;
  height: number;
  timestamp: number;
}

interface UsageData {
  userId: string;
  generations: number;
  lastResetDate: string;
  canGenerate: boolean;
  remainingGenerations: number;
  timeUntilReset: number;
  limit: number;
}

interface WallpaperGeneratorProps {
  theme: 'dark' | 'light';
  width: number;
  height: number;
  onImageGenerated: (image: SavedImage) => void;
}

const WallpaperGenerator: React.FC<WallpaperGeneratorProps> = ({
  theme,
  width,
  height,
  onImageGenerated
}) => {
  const [prompt, setPrompt] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [showPreview, setShowPreview] = useState(false);
  const [showPromptModal, setShowPromptModal] = useState(false);
  const [usage, setUsage] = useState<UsageData>({
    userId: '',
    generations: 0,
    canGenerate: true,
    remainingGenerations: 2,
    timeUntilReset: 0,
    limit: 2,
    lastResetDate: ''
  });
  const [userId, setUserId] = useState<string>('');

  const siteName = typeof window !== 'undefined' ? 
    window.location.hostname.replace('www.', '').split('.')[0] || 'WallCraft' : 'WallCraft';

  // Generate or get user ID
  useEffect(() => {
    if (typeof window !== 'undefined') {
      let storedUserId = localStorage.getItem('wallcraft_user_id');
      if (!storedUserId) {
        storedUserId = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        localStorage.setItem('wallcraft_user_id', storedUserId);
      }
      setUserId(storedUserId);
    }
  }, []);

  // Load usage data
  useEffect(() => {
    if (userId) {
      loadUsageData();
    }
  }, [userId]);

  const loadUsageData = async () => {
    try {
      const today = new Date().toDateString();
      const storedUsage = typeof window !== 'undefined' ? localStorage.getItem(`usage_${userId}`) : null;
      
      if (storedUsage) {
        const parsedUsage = JSON.parse(storedUsage);
        if (parsedUsage.lastResetDate === today) {
          setUsage(parsedUsage);
          return;
        }
      }

      // Reset for new day
      const newUsage: UsageData = {
        userId,
        generations: 0,
        lastResetDate: today,
        canGenerate: true,
        remainingGenerations: 2,
        timeUntilReset: getTimeUntilReset(),
        limit: 2
      };
      
      setUsage(newUsage);
      if (typeof window !== 'undefined') {
        localStorage.setItem(`usage_${userId}`, JSON.stringify(newUsage));
      }
    } catch (error) {
      console.error('Error loading usage data:', error);
    }
  };

  const getTimeUntilReset = () => {
    const now = new Date();
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(0, 0, 0, 0);
    return tomorrow.getTime() - now.getTime();
  };

  const updateUsageData = async (newUsage: UsageData) => {
    try {
      if (typeof window !== 'undefined') {
        localStorage.setItem(`usage_${userId}`, JSON.stringify(newUsage));
      }
      setUsage(newUsage);
    } catch (error) {
      console.error('Error updating usage data:', error);
    }
  };

  const addWatermark = (canvas: HTMLCanvasElement, imageUrl: string): Promise<string> => {
    return new Promise((resolve) => {
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      
      const img = new Image();
      
      img.onload = () => {
        // Draw the original image
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        // Add watermark
        const fontSize = Math.max(12, Math.min(canvas.width, canvas.height) / 40);
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        
        const watermarkText = siteName;
        const textMetrics = ctx.measureText(watermarkText);
        const x = canvas.width - textMetrics.width - 20;
        const y = canvas.height - 20;
        
        ctx.strokeText(watermarkText, x, y);
        ctx.fillText(watermarkText, x, y);
        
        // Convert to blob and create URL
        canvas.toBlob((blob) => {
          if (blob) {
            resolve(URL.createObjectURL(blob));
          }
        }, 'image/jpeg', 0.9);
      };
      
      img.src = imageUrl;
    });
  };

  const handleGenerate = async () => {
    if (!prompt.trim()) {
      setError('Enter a prompt');
      return;
    }

    if (!usage?.canGenerate) {
      setError('Generation limit reached. Please wait until tomorrow.');
      return;
    }

    setIsGenerating(true);
    setError(null);
    setShowPromptModal(false);

    try {
      const response = await fetch('/api/generate-wallpaper', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt: prompt.trim(),
          width,
          height,
          userId
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to generate image');
      }

      // Get the image as blob
      const imageBlob = await response.blob();
      const imageUrl = URL.createObjectURL(imageBlob);

      // Create canvas and add watermark
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      
      const watermarkedImageUrl = await addWatermark(canvas, imageUrl);
      
      setGeneratedImage(watermarkedImageUrl);
      setShowPreview(true);
      
      const newImage: SavedImage = {
        id: `img_${Date.now()}`,
        url: watermarkedImageUrl,
        prompt,
        width,
        height,
        timestamp: Date.now(),
      };
      
      onImageGenerated(newImage);
      
      // Update usage
      const newUsage: UsageData = {
        ...usage,
        generations: usage.generations + 1,
        remainingGenerations: usage.remainingGenerations - 1,
        canGenerate: usage.remainingGenerations > 1,
        timeUntilReset: getTimeUntilReset()
      };
      
      await updateUsageData(newUsage);
      
    } catch (error) {
      console.error('Error generating image:', error);
      setError(error instanceof Error ? error.message : 'Failed to generate image');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleDownload = (imageUrl: string, prompt: string, width: number, height: number) => {
    const link = document.createElement('a');
    link.href = imageUrl;
    link.download = `${siteName}-wallpaper-${width}x${height}-${Date.now()}.jpg`;
    link.click();
  };

  const formatTimeUntilReset = (ms: number) => {
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    return `${hours}h ${minutes}m`;
  };

  const themeClasses = {
    dark: {
      bg: 'bg-gray-900',
      text: 'text-white',
      card: 'bg-gray-800',
      input: 'bg-gray-700 border-gray-600 text-white',
      button: 'bg-gray-800 hover:bg-gray-700',
      modal: 'bg-gray-800',
    },
    light: {
      bg: 'bg-gray-50',
      text: 'text-gray-900',
      card: 'bg-white',
      input: 'bg-white border-gray-300 text-gray-900',
      button: 'bg-gray-200 hover:bg-gray-300',
      modal: 'bg-white',
    }
  };

  const currentTheme = themeClasses[theme];

  return (
    <>
      {/* Usage Display */}
      <div className={`px-2 py-1 rounded-lg text-xs ${theme === 'dark' ? 'bg-gray-700' : 'bg-gray-200'}`}>
        {usage.canGenerate ? (
          `${usage.remainingGenerations} left`
        ) : (
          <div className="flex items-center gap-1">
            <Clock size={12} />
            {formatTimeUntilReset(usage.timeUntilReset)}
          </div>
        )}
      </div>

      {/* Generate Section */}
      <div className="space-y-4">
        <div className={`rounded-2xl ${currentTheme.card} p-6 text-center`}>
          <div className={`inline-block px-3 py-1 rounded-full text-xs mb-6 ${theme === 'dark' ? 'bg-gray-700' : 'bg-gray-200'}`}>
            {width} Ã— {height}
          </div>
          
          <button
            onClick={() => setShowPromptModal(true)}
            disabled={!usage.canGenerate}
            className="w-full py-4 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 disabled:opacity-50 text-white font-medium rounded-xl transition-all text-lg"
          >
            <Sparkles className="inline mr-2" size={20} />
            {usage.canGenerate ? 'Generate Wallpaper' : 'Limit Reached'}
          </button>

          {!usage.canGenerate && (
            <div className="mt-4 p-3 bg-yellow-500/20 border border-yellow-500/30 rounded-xl text-yellow-300 text-sm">
              Daily limit reached. Reset in {formatTimeUntilReset(usage.timeUntilReset)}
            </div>
          )}

          {error && (
            <div className="mt-4 p-3 bg-red-500/20 border border-red-500/30 rounded-xl text-red-300 text-sm">
              {error}
            </div>
          )}
        </div>
      </div>

      {/* Prompt Modal */}
      {showPromptModal && (
        <div className="fixed inset-0 bg-black/50 flex items-end justify-center z-50 p-4">
          <div className={`${currentTheme.modal} rounded-t-3xl w-full max-w-md transform transition-transform duration-300 ${showPromptModal ? 'translate-y-0' : 'translate-y-full'}`}>
            <div className="p-6">
              <div className="w-12 h-1 bg-gray-400 rounded-full mx-auto mb-4"></div>
              <h3 className="text-lg font-semibold mb-4">Describe your wallpaper</h3>
              
              <textarea
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder="e.g., Minimalist sunset over mountains with purple and orange gradient..."
                className={`w-full p-4 rounded-2xl ${currentTheme.input} resize-none text-sm`}
                rows={4}
                autoFocus
              />

              <div className="flex gap-3 mt-4">
                <button
                  onClick={() => setShowPromptModal(false)}
                  className={`flex-1 py-3 ${currentTheme.button} rounded-xl text-sm`}
                >
                  Cancel
                </button>
                <button
                  onClick={handleGenerate}
                  disabled={!prompt.trim() || !usage.canGenerate}
                  className="flex-1 py-3 bg-blue-500 hover:bg-blue-600 disabled:opacity-50 text-white rounded-xl text-sm font-medium"
                >
                  Generate
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Magic Loading Overlay */}
      {isGenerating && (
        <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
          <div className="text-center text-white">
            <div className="relative mb-6">
              <div className="w-20 h-20 rounded-full border-4 border-purple-500/30 border-t-purple-500 animate-spin mx-auto"></div>
              <Sparkles className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-purple-400 animate-pulse" size={32} />
            </div>
            <h3 className="text-xl font-semibold mb-2">Creating Magic âœ¨</h3>
            <p className="text-purple-300 text-sm">AI is generating your wallpaper...</p>
            <p className="text-purple-400 text-xs mt-2">This may take 30-60 seconds</p>
          </div>
        </div>
      )}

      {/* Download Preview Modal */}
      {showPreview && generatedImage && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
          <div className="max-w-xs w-full">
            <button
              onClick={() => { setShowPreview(false); setGeneratedImage(null); }}
              className="absolute -top-10 right-0 w-8 h-8 bg-white/20 rounded-full flex items-center justify-center text-white"
            >
              <X size={16} />
            </button>

            <div className="bg-white rounded-3xl p-4 shadow-2xl">
              <img
                src={generatedImage}
                alt="Generated wallpaper"
                className="w-full rounded-2xl"
                style={{ maxHeight: '280px', objectFit: 'cover' }}
              />

              <div className="flex gap-3 mt-4">
                <button
                  onClick={() => handleDownload(generatedImage, prompt, width, height)}
                  className="flex-1 py-3 bg-green-500 hover:bg-green-600 text-white rounded-2xl text-sm font-medium"
                >
                  <Download size={14} className="inline mr-2" />
                  Download
                </button>
                <button
                  onClick={() => { setShowPreview(false); setGeneratedImage(null); }}
                  className="px-6 py-3 bg-gray-500 hover:bg-gray-600 text-white rounded-2xl text-sm"
                >
                  Close
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </>
  );
};

export default WallpaperGenerator;